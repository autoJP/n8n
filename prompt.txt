Вот описание системы.
Система состоит из нескольких отдельных рабочих процессов в n8n и одного управляющего workflow, который выполняет роль центрального диспетчера. Все данные о состоянии берутся только из DefectDojo, никакой внешней базы или очереди задач нет. Основная идея в том, что каждый рабочий процесс занимается только одной маленькой задачей, а главный workflow регулярно проверяет состояние в Dojo и запускает нужные процессы в нужный момент. За счёт этого система устойчива к сбоям: падение одной задачи не влияет на остальные.
Базовым объектом в Dojo служит Product Type. Это, по сути, целевой домен, с которым связаны дальнейшие действия. Product Type считается новым и требующим первичной обработки, если в Dojo по нему нет ни одного Product. Таким образом, отсутствие продуктов является признаком того, что субдомены ещё не собирались, и такой Product Type должен быть передан в обработку первому рабочему процессу.
Первый рабочий процесс, WF_A_Subdomains_PT, принимает один Product Type, получает его домен и запускает скрипт для сбора поддоменов. Скрипт возвращает найденные хосты или поддомены. Для каждого найденного хоста workflow создаёт в Dojo новый Product, привязывает его к текущему Product Type и помечает тегом needs:nmap. Этот тег означает, что по объекту необходимо выполнить сканирование nmap. Workflow обрабатывает только один Product Type за запуск; в случае ошибки она фиксируется в n8n, но данные в Dojo не повреждаются.
Второй рабочий процесс, WF_B_Nmap_Product, принимает один Product (то есть один субдомен или хост). Он выполняет nmap, сохраняет XML-отчёт и импортирует результаты в Dojo через API. Если работа проходит успешно, тег needs:nmap у данного Product удаляется. Выполняется скрипт, который парсит xml результат nmap и если host is up - присваивает ему internet_accessible. Если nmap падает, на Product ставится тег nmap:failed, и workflow заканчивает выполнение, не влияя на другие объекты. Каждый запуск работает только над одним Product, что предотвращает каскадные ошибки.

Следующий модуль, WF_C_Targets_For_PT, отвечает за подготовку полной картины целей для Acunetix на уровне одного Product Type. Он работает строго с одним Product Type за запуск и выполняет два больших шага.
Сначала workflow приводит структуру Products в Dojo к консистентному состоянию. Для указанного Product Type он обходит все связанные Products, ищет соответствующие им Nmap-отчёты и на их основе создаёт недостающие продукты вида IP:port. Эти продукты отражают фактические внешние сервисы, обнаруженные на хостах, и автоматически помечаются как internet_accessible = true. Операция идемпотентна: повторный запуск не создаёт дубликаты и просто дополняет картину при появлении новых сервисов.
После этого workflow получает полный список всех Products данного Product Type, фильтрует только те, которые имеют internet_accessible = true, и на их основе формирует конечный набор целей (URLs), подходящих для сканирования Acunetix. Далее запускается Python-скрипт, который, исходя из целевого Product Type, создаёт или обновляет соответствующую target group и набор targets в Acunetix. Скрипт также идемпотентен: повторный запуск только актуализирует конфигурацию, не нарушая уже существующих данных.
WF_C не использует теги и не хранит состояние. Факт наличия готовой группы и её состав определяются напрямую через API Acunetix и актуальное состояние Dojo.

WF_D_AcunetixScan_PT — это workflow, который выполняет запуск сканов Acunetix. Он получает идентификатор Product Type или target group, выбирает Acunetix-сервер на основе свободных слотов, создаёт новый скан и начинает опрос состояния. Когда скан завершён, workflow скачивает отчёт и импортирует его в Dojo через API. Ошибка скана затрагивает только текущий Product Type, остальные процессы продолжают работать.
Над всем этим стоит главный управляющий процесс — WF_Master_DoJoWatcher. Он запускается по расписанию, например каждые пять минут. При каждом запуске Master делает несколько последовательных шагов. Сначала он опрашивает Dojo на предмет Product Type, у которых нет ни одного Product. Каждый такой Product Type передаётся в WF_A_Subdomains_PT. Затем Master ищет все Products с тегом needs:nmap и запускает для каждого WF_B_Nmap_Product. После этого он ищет Product Type, по которым все nmap-задания завершены, но цели в Acunetix ещё не подготовлены, и вызывает WF_C_Targets_For_PT. Наконец, Master проверяет, какие Product Type готовы к сканированию Acunetix, выбирает подходящую ноду и запускает WF_D_AcunetixScan_PT. Благодаря тому, что каждый вызов Execute Workflow создаёт отдельный execution в n8n, система способна выполнять множество рабочих процессов параллельно, при этом Master остаётся простым детектором состояния.
Таким образом, система построена по принципу «мастер + трудовые процессы». Master следит за состоянием объектов в Dojo, а рабочие workflow выполняют точечные действия. Логика отказов максимально проста: любая проблема изолируется на уровне одного Product или Product Type, а Master просто подождёт следующего цикла. Система расширяема, не требует хранения состояния вне Dojo и позволяет безопасно запускать несколько сотен задач в сутки, не рискуя разрушить весь процесс одним неудачным сканированием.


Итоговый список нод n8n, приведённый к описанию системы.
WF_A_Subdomains_PT
Trigger (Execute Workflow) – вход из Master с параметром product_type_id (и опционально доменом)
Parameter Input / Set – нормализация входных параметров (product_type_id, domain)
HTTP Request (GET) – запрос в DefectDojo по ID Product Type для получения домена, если он не передан
Function – извлечение домена из ответа или входных параметров
Execute Command – запуск скрипта сбора поддоменов (enum_subs_auto.py) с передачей домена
IF – проверка успешности выполнения скрипта
Function – парсинг результата скрипта в список найденных хостов/поддоменов
Split In Batches – разделение списка хостов на отдельные элементы для поштучной обработки
HTTP Request (POST) – создание Product в DefectDojo для каждого хоста (name, prod_type, description)
HTTP Request (POST) – добавление тега needs:nmap к созданному Product (если тег не задан при создании)
Function – формирование итогового отчёта по количеству созданных Products и найденных хостов
Error Trigger – обработка ошибок с логированием в n8n (при падении какого-то шага)
WF_B_Nmap_Product
Trigger (Execute Workflow) – старт по вызову из Master с параметром product_id
HTTP Request (GET) – получение данных Product из DefectDojo по ID
Function – извлечение хоста/адреса для сканирования (домен или IP)
Execute Command – запуск nmap с сохранением XML-отчёта в файл
IF – проверка кода возврата nmap и успешности выполнения
HTTP Request (POST) – при успехе импорт XML-отчёта в DefectDojo через API импорта сканов
HTTP Request (PATCH/POST) – при успехе обновление Product с удалением тега needs:nmap
HTTP Request (POST) – при ошибке nmap обновление Product с добавлением тега nmap:failed
Function – формирование итогового отчёта по результату скана и изменению тегов
Error Trigger – обработка ошибок с логированием в n8n
WF_C_Targets_For_PT
Trigger (Execute Workflow) – старт по вызову из Master с параметром product_type_id
HTTP Request (GET) – получение списка Products для данного Product Type из DefectDojo
Function – фильтрация Products с признаком internet_accessible (атрибут в Dojo, не тег состояния)
Function – формирование списка целей (URL/hostname/порт) для Acunetix на основе отфильтрованных Products
Execute Command – запуск идемпотентного Python-скрипта для работы с Acunetix API (создание/обновление target group и targets для данного Product Type)
Function – обработка вывода скрипта (успех/ошибка, ID target group, количество целей)
Function – формирование итогового отчёта по подготовленным целям
WF_D_AcunetixScan_PT
Trigger (Execute Workflow) – старт по вызову из Master с параметром product_type_id или target_group_id
HTTP Request (GET) – при работе по product_type_id получение через Acunetix API target group, связанной с этим Product Type (или проверка её наличия)
HTTP Request (GET) – запрос состояния Acunetix-серверов (количество активных сканов, лимиты слотов)
Function – выбор подходящей Acunetix-ноды на основе свободных слотов
HTTP Request (POST) – создание нового скана в Acunetix для соответствующей target group на выбранной ноде
Wait & Loop – цикл ожидания и повторной проверки статуса скана
HTTP Request (GET) – внутри цикла опрос состояния скана в Acunetix API
IF – проверка, завершён ли скан и каков результат (успех/ошибка); при незавершённом скане возврат в Wait & Loop
HTTP Request (GET) – при успешном завершении скачивание отчёта скана из Acunetix
HTTP Request (POST) – импорт отчёта в DefectDojo через API
Function – формирование итоговой записи о выполнении скана для данного Product Type
WF_E_Health
Schedule Trigger – запуск по расписанию (например, каждые 15 минут)
HTTP Request (GET) – проверка доступности и базового ответа DefectDojo (health-check API или простой запрос к /api/v2)
HTTP Request (GET) – проверка доступности Acunetix-ноды (или нескольких нод) через их API
HTTP Request (GET) – при наличии отдельного endpoint проверка состояния самого n8n (например, /health)
Function – сбор и агрегация статусов всех проверок в единый объект (up/down, задержка, сообщения об ошибках)
IF – проверка наличия критических сбоев (недоступность ключевых сервисов)
HTTP Request (POST) – отправка уведомления о критических проблемах (email/telegram/webhook)
Function – логирование результата проверки здоровья (структурированные данные)
WF_Master_DoJoWatcher
Schedule Trigger – запуск по расписанию, каждые 5 минут
HTTP Request (GET) – поиск в DefectDojo Product Type, по которым нет ни одного Product (новые домены для первичной обработки)
Split In Batches – разделение списка таких Product Type на отдельные элементы
Execute Workflow – запуск WF_A_Subdomains_PT для каждого Product Type
HTTP Request (GET) – поиск Products с тегом needs:nmap в DefectDojo
Split In Batches – разделение найденных Products на отдельные элементы
Execute Workflow – запуск WF_B_Nmap_Product для каждого Product с needs:nmap
HTTP Request (GET) – получение списка Product Type, для которых все связанные Products больше не имеют тега needs:nmap (все nmap-задания завершены)
HTTP Request (GET) – получение из Acunetix информации о target group, связанных с этими Product Type
Function – определение Product Type, для которых цели ещё не подготовлены (target group отсутствует или неполна)
Split In Batches – разделение этих Product Type
Execute Workflow – запуск WF_C_Targets_For_PT для каждого Product Type без подготовленных целей
HTTP Request (GET) – получение списка Product Type, для которых цели Acunetix уже подготовлены (target group есть) и нет активных сканов по этим группам
HTTP Request (GET) – запрос текущего состояния Acunetix-серверов и доступных слотов
Function – выбор подмножества Product Type для сканирования и распределение их по доступным нодам
Split In Batches – разделение выбранных заданий на элементы
Execute Workflow – запуск WF_D_AcunetixScan_PT для каждого Product Type, готового к скану
Function – формирование итогового статуса выполнения цикла (количество PT/Products, отправленных в WF_A, WF_B, WF_C, WF_D; возможные ошибки)
Эта версия уже совпадает с тем, как система описана текстом: один PT или один Product на запуск, состояние только в Dojo и Acunetix, мастер как чистый оркестратор, а рабочие WF делают по одной маленькой задаче.
Вот доступ к додзё:
"DOJO_BASE_URL", "http://localhost:8080/api/v2"
header
# Format is ``Authorization: Token <api_key>
Authorization: Token 8772f6e093f7a9e5eee8241b393131a5ae6e7260

У тебя есть файлы скриптов - можешь их использовать, если необходимо.
Они лежат в папке /opt/tools/. Никаких других папок кроме этой и системной tmp создавать или использовать не нужно.

Не добавляй функционал без явного указания. Видишь пробел в логике или ошибку - говори, не исправляй сразу.

Дай код третьего пайплайна WF_C_Targets_For_PT.
